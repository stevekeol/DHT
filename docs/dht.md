# 分布式散列表DHT的底层逻辑和实现机制

## 背景
在参与`移动端全节点公有链`的研发中，海量数据如何在节点中均匀的存储和快速的获取是一座迈不过的大山。因此，以什么样的结构将网络中的所有节点组织起来，每个节点又该如何组织自身存储的数据。这便是`DHT`需要解决的问题。

本文尝试梳理以下的一些问题：
+ 海量数据如何均匀存储在多个节点上(尤其是移动端)
+ 如何缓解节点频繁进入和退出对整个节点网络造成的抖动
+ 如何高效的查询一个并不知道目的地的数据文件

本文关键词：
+ 拓扑结构的设计
+ 逻辑距离的定义
+ 路由算法的权衡
+ 路由表大小的折中和动态调整
+ 数据存取时的定位逻辑


## 朴素想法

抛开一切当下思绪和前置经验。试想，我们现在有N台移动节点，如何去存取一个数据文件/数据片段？

最朴素的想法就是，挑选一台性能好的，存储空间大的节点X，数据就存节点X上。其余节点定向找到节点X按需存取即可。

没错，这就是P2P文件共享的发展史上，第一代的模式：`中央服务器`模式。

缺点明显: 节点X的“跑路”，会导致整个P2P网络的`单点故障`。

进一步的朴素想法就是，数据文件“随机”存储在某节点，需要查询该数据文件时，我挨个节点的询问呗，哪怕千辛万苦，我总能在某个角落的节点上找到该数据文件吧。

这便是P2P文件共享的第二代模式：`广播`模式。即：要找文件的时候，每个节点都向自己相连的“所有节点”进行询问，假如被询问的节点不知道文件在哪，就再次进行`广播`，如此往复，直至找到所需文件。

缺点也很明显：这将引发 `广播风暴` ，节点自身的系统资源大量浪费（同一个节点可能多次收到该广播事件,并重复进行相同的处理流程），整个节点网络的带宽也在忙于寻找该文件。

> 但是，假如每个节点相连的都是自己精挑细选出来的`有限的`，`合适的`节点呢？假如我们能保证每一次的 `广播` 都是在确确实实的逼近所需的数据文件呢（即：哪怕当前节点不知道数据文件的位置，但知道自己所连的节点中，哪些节点是更可能知道位置的）？这样，我们每次(定向）广播的对象个数是有限的，且广播的次数是有限的。

直觉告诉我们，似乎可行。那么我们尝试将上述朴素的猜想，抽象出数学模型。

## 简化的数学模型

由以上的猜想: 
1. 每个节点要存储尽可能少的节点，但同时要保证能覆盖整个节点网络;
2. 节点A收到查询数据D的消息后，节点A自身能知道自己和自己直接相连的所有节点中，哪个节点是离D最近的;

第一个问题便是: 每个节点该以怎样的数据结构来组织所连的其它节点，来构成一个精简的全网节点拓扑图？

#### 一. 拓扑结构（Overlay Network）
继续简化该模型，假设现在全网就 `N = 8` (N = 2^n)个节点，它们该如何彼此互联?

朴素想法1:
```
N0: [N1];
N1: [N2];
...
N6: [N7];
```

朴素想法2:
```
N0: [N1, N2, N3, N4, N5, N6, N7];
N1: [N0, N2, N3, N4, N5, N6, N7];
...
N7: [N0, N1, N2, N3, N4, N5, N6];
```

想法1和2均是利用了极限思维：每个节点就连接一个节点；每个节点连接其他所有节点。

+ 想法1的缺点同样在于: `单点故障` - 假如N4不可用，则网络分裂为N0 ~ N3和N5 ~ N7两个彼此孤立的网络;
+ 想法2的缺点同样在于: `广播风暴`;


因此，需要在1~N之间选取某个合适的阈值（范围）, 使得满足上述两个条件。先看看下图:
【图1: 8节点立方体】
即:
```
A: [B, C, D];
B: [A, E, G];
C: [A, F, G];
D: [A, E, F];
E: [B, D, H];
F: [C, D, H];
G: [B, C, H];
H: [E, F, G];
```
观察得知：
+ 每个节点存储的邻居节点个数（也称节点的 `度数` ）为: `lg(N)`;
+ 每个节点存储的邻居们，是尽可能 `正交` 的（即尽可能避免无意义的冗余）;

该节点网络拓扑图的美感和稳定性，不言而喻。
+ 既避免`单点故障`；
+ 也避免`广播风暴`：当前节点A需要去查询节点X，那么只需在直连的B,C,D中选取可用的，且最接近X的邻居节点。该邻居节点重复该过程，逐步逼近节点X即可。

这便引入了第二个问题: 如何判断节点A和节点B之间的逻辑距离？

#### 二. 逻辑距离的定义
需要明确下，A节点到B节点的距离，不是物理空间上的距离，而是逻辑意义上的距离。但即便如此，也需要符合`距离` 的基本要义:
+ 节点A到自身的距离为0;
+ 节点A到节点B的距离 等于 节点B到节点A的距离;
+ 节点A到节点B再到节点C的距离，大于 节点A直接到节点C的距离;

> 该逻辑距离用来判断：节点之间的距离，数据之间的距离，节点与数据之间的距离。

那么有没有这样的算法，可以快速简洁的计算出该逻辑距离呢?
+ 第一种： 向量夹角法;
+ 第二种： （按位）`异或` 法;

> `向量夹角法` 是笔者自己脑暴想出来的。大致意思是：每个节点自身存储的节点表：[n1, n2, ... nn]，构成了n维（即lgN）的线性空间，两个节点之间可以利用余弦定理求出两个向量的夹角大小，来衡量两个节点的逻辑距离。但弊端太多了，一是计算量大；二是需要去获取除节点自身信息以外的其它节点的信息; 因此废弃该想法！

假如有三个节点A(001), B(110), C(101)。先验证下`距离`的三要义:
+ 001 ^ 001: 000

下面来看看 `XOR异或法` 的精妙之处:

